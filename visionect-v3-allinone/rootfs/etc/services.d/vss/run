#!/usr/bin/with-contenv bash
set -euo pipefail

# Ustawienia z options.json
VSA=$(jq -r '.visionect_server_address' /data/options.json)
PGUSER=$(jq -r '.postgres_user' /data/options.json)
PGPASS=$(jq -r '.postgres_password' /data/options.json)
PGDB=$(jq -r '.postgres_db' /data/options.json)

# Czekaj na Redis
echo "[vss] Waiting for Redis on 127.0.0.1:6379 ..."
for i in {1..60}; do
  if redis-cli -h 127.0.0.1 -p 6379 ping >/dev/null 2>&1; then
    break
  fi
  sleep 1
done

# Inicjalizacja bazy
init_pg.sh

# Export env dla Visionect
export DB2_1_PORT_5432_TCP_ADDR="127.0.0.1"
export DB2_1_PORT_5432_TCP_USER="${PGUSER}"
export DB2_1_PORT_5432_TCP_PASS="${PGPASS}"
export DB2_1_PORT_5432_TCP_DB="${PGDB}"
export REDIS_ADDRESS="127.0.0.1:6379"
export VISIONECT_SERVER_ADDRESS="${VSA}"

# Ulimit jak w docker-compose
ulimit -c 0 || true

echo "[vss] Starting Visionect Server v3 ..."
# Próba znalezienia typowego entrypointu/binarki (w obrazie Visionect to zazwyczaj któryś z poniższych)
CANDIDATES=(
  "/docker-entrypoint.sh"
  "/entrypoint.sh"
  "/start.sh"
  "/usr/local/bin/start.sh"
  "/usr/bin/vss"
  "/usr/local/bin/vss"
  "/visionect-server"
  "/app"
)

for P in "${CANDIDATES[@]}"; do
  if [[ -x "$P" ]]; then
    exec "$P"
  fi
done

echo "[vss] ERROR: Visionect entrypoint not found. Please adjust services.d/vss/run with the correct path." >&2
sleep 2
exit 1